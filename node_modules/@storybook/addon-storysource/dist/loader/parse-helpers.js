'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleADD = handleADD;
exports.handleSTORYOF = handleSTORYOF;
var STORIES_OF = 'storiesOf';

function pushParts(source, parts, from, to) {
  var start = source.slice(from, to);
  parts.push(start);

  var end = source.slice(to);
  parts.push(end);
}

function getKindFromStoryOfNode(object) {
  if (object.arguments.length < 1) {
    return '';
  }

  var kindArgument = object.arguments[0];

  if (kindArgument.type === 'Literal') {
    return kindArgument.value;
  }

  if (kindArgument.type === 'TemplateLiteral') {
    // we can generate template, but it will not be a real value
    // until the full template compilation. probably won't fix.
    return '';
  }

  // other options may include some complex usages.
  return '';
}

function findRelatedKind(object) {
  if (!object || !object.callee) {
    return '';
  }

  if (object.callee.name === STORIES_OF) {
    return getKindFromStoryOfNode(object);
  }

  return findRelatedKind(object.callee.object);
}

function handleADD(node, parent, adds) {
  if (!node.property || !node.property.name || node.property.name.indexOf('add') !== 0) {
    return;
  }

  var addArgs = parent.arguments;

  if (!addArgs || addArgs.length < 2) {
    return;
  }

  var storyName = addArgs[0];
  var lastArg = addArgs[addArgs.length - 1];

  if (storyName.type !== 'Literal') {
    // if story name is not literal, it much harder to extract it
    return;
  }

  var kind = findRelatedKind(node.object) || '';
  var key = kind + '@' + storyName.value;

  // eslint-disable-next-line no-param-reassign
  adds[key] = {
    // Debug: code: source.slice(storyName.start, lastArg.end),
    startLoc: {
      col: storyName.loc.start.column,
      line: storyName.loc.start.line
    },
    endLoc: {
      col: lastArg.loc.end.column,
      line: lastArg.loc.end.line
    }
  };
}

function handleSTORYOF(node, parts, source, lastIndex) {
  if (!node.callee || !node.callee.name || node.callee.name !== STORIES_OF) {
    return lastIndex;
  }

  parts.pop();
  pushParts(source, parts, lastIndex, node.end);
  return node.end;
}